{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/USER/OneDrive/Documents/Coblabsite/blaffa_site/src/lib/axios.ts"],"sourcesContent":["import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios';\r\n\r\nconst API_URL = 'https://api.blaffa.net';\r\n\r\n// Create axios instance with base URL\r\nconst api = axios.create({\r\n  baseURL: API_URL,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n});\r\n\r\nlet isRefreshing = false;\r\nlet failedQueue: Array<{\r\n  resolve: (token: string) => void;\r\n  reject: (error: unknown) => void;\r\n}> = [];\r\n\r\nconst processQueue = (error: unknown, token: string | null = null) => {\r\n  failedQueue.forEach(prom => {\r\n    if (error) {\r\n      prom.reject(error);\r\n    } else {\r\n      prom.resolve(token!);\r\n    }\r\n  });\r\n  failedQueue = [];\r\n};\r\n\r\n// Request interceptor to add auth token\r\napi.interceptors.request.use(\r\n  (config) => {\r\n    const token = localStorage.getItem('accessToken');\r\n    if (token) {\r\n      config.headers.Authorization = `Bearer ${token}`;\r\n    }\r\n    return config;\r\n  },\r\n  (error) => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor to handle token refresh\r\napi.interceptors.response.use(\r\n  (response) => response,\r\n  async (error: AxiosError) => {\r\n    const originalRequest = error.config as InternalAxiosRequestConfig & { _retry?: boolean };\r\n\r\n    // If the error is 401 and we haven't tried to refresh yet\r\n    if (error.response?.status === 401 && !originalRequest._retry) {\r\n      if (isRefreshing) {\r\n        // If we're already refreshing, add the request to the queue\r\n        return new Promise((resolve, reject) => {\r\n          failedQueue.push({ resolve, reject });\r\n        })\r\n          .then((token) => {\r\n            originalRequest.headers.Authorization = `Bearer ${token}`;\r\n            return api(originalRequest);\r\n          })\r\n          .catch((err) => {\r\n            return Promise.reject(err);\r\n          });\r\n      }\r\n\r\n      originalRequest._retry = true;\r\n      isRefreshing = true;\r\n\r\n      try {\r\n        const refreshToken = localStorage.getItem('refreshToken');\r\n        if (!refreshToken) {\r\n          // No refresh token available, redirect to login\r\n          localStorage.removeItem('accessToken');\r\n          window.location.href = '/login';\r\n          return Promise.reject(error);\r\n        }\r\n\r\n        // Try to refresh the token\r\n        const response = await axios.post(\r\n          `${API_URL}/auth/refresh`,\r\n          { refresh: refreshToken },\r\n          { headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n\r\n        const { access, refresh: newRefresh } = response.data;\r\n\r\n        // Update tokens in localStorage\r\n        localStorage.setItem('accessToken', access);\r\n        if (newRefresh) {\r\n          localStorage.setItem('refreshToken', newRefresh);\r\n        }\r\n\r\n        // Update the Authorization header\r\n        api.defaults.headers.common.Authorization = `Bearer ${access}`;\r\n        originalRequest.headers.Authorization = `Bearer ${access}`;\r\n\r\n        // Process the queue\r\n        processQueue(null, access);\r\n\r\n        // Retry the original request\r\n        return api(originalRequest);\r\n      } catch (refreshError) {\r\n        // If refresh fails, clear tokens and redirect to login\r\n        console.error('Failed to refresh token:', refreshError);\r\n        localStorage.removeItem('accessToken');\r\n        localStorage.removeItem('refreshToken');\r\n        window.location.href = '/login';\r\n        processQueue(refreshError);\r\n        return Promise.reject(refreshError);\r\n      } finally {\r\n        isRefreshing = false;\r\n      }\r\n    }\r\n\r\n    // For other errors, just reject\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default api;"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,UAAU;AAEhB,sCAAsC;AACtC,MAAM,MAAM,gJAAK,CAAC,MAAM,CAAC;IACvB,SAAS;IACT,SAAS;QACP,gBAAgB;IAClB;AACF;AAEA,IAAI,eAAe;AACnB,IAAI,cAGC,EAAE;AAEP,MAAM,eAAe,CAAC,OAAgB,QAAuB,IAAI;IAC/D,YAAY,OAAO,CAAC,CAAA;QAClB,IAAI,OAAO;YACT,KAAK,MAAM,CAAC;QACd,OAAO;YACL,KAAK,OAAO,CAAC;QACf;IACF;IACA,cAAc,EAAE;AAClB;AAEA,wCAAwC;AACxC,IAAI,YAAY,CAAC,OAAO,CAAC,GAAG,CAC1B,CAAC;IACC,MAAM,QAAQ,aAAa,OAAO,CAAC;IACnC,IAAI,OAAO;QACT,OAAO,OAAO,CAAC,aAAa,GAAG,CAAC,OAAO,EAAE,OAAO;IAClD;IACA,OAAO;AACT,GACA,CAAC;IACC,OAAO,QAAQ,MAAM,CAAC;AACxB;AAGF,+CAA+C;AAC/C,IAAI,YAAY,CAAC,QAAQ,CAAC,GAAG,CAC3B,CAAC,WAAa,UACd,OAAO;IACL,MAAM,kBAAkB,MAAM,MAAM;IAEpC,0DAA0D;IAC1D,IAAI,MAAM,QAAQ,EAAE,WAAW,OAAO,CAAC,gBAAgB,MAAM,EAAE;QAC7D,IAAI,cAAc;YAChB,4DAA4D;YAC5D,OAAO,IAAI,QAAQ,CAAC,SAAS;gBAC3B,YAAY,IAAI,CAAC;oBAAE;oBAAS;gBAAO;YACrC,GACG,IAAI,CAAC,CAAC;gBACL,gBAAgB,OAAO,CAAC,aAAa,GAAG,CAAC,OAAO,EAAE,OAAO;gBACzD,OAAO,IAAI;YACb,GACC,KAAK,CAAC,CAAC;gBACN,OAAO,QAAQ,MAAM,CAAC;YACxB;QACJ;QAEA,gBAAgB,MAAM,GAAG;QACzB,eAAe;QAEf,IAAI;YACF,MAAM,eAAe,aAAa,OAAO,CAAC;YAC1C,IAAI,CAAC,cAAc;gBACjB,gDAAgD;gBAChD,aAAa,UAAU,CAAC;gBACxB,OAAO,QAAQ,CAAC,IAAI,GAAG;gBACvB,OAAO,QAAQ,MAAM,CAAC;YACxB;YAEA,2BAA2B;YAC3B,MAAM,WAAW,MAAM,gJAAK,CAAC,IAAI,CAC/B,GAAG,QAAQ,aAAa,CAAC,EACzB;gBAAE,SAAS;YAAa,GACxB;gBAAE,SAAS;oBAAE,gBAAgB;gBAAmB;YAAE;YAGpD,MAAM,EAAE,MAAM,EAAE,SAAS,UAAU,EAAE,GAAG,SAAS,IAAI;YAErD,gCAAgC;YAChC,aAAa,OAAO,CAAC,eAAe;YACpC,IAAI,YAAY;gBACd,aAAa,OAAO,CAAC,gBAAgB;YACvC;YAEA,kCAAkC;YAClC,IAAI,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,aAAa,GAAG,CAAC,OAAO,EAAE,QAAQ;YAC9D,gBAAgB,OAAO,CAAC,aAAa,GAAG,CAAC,OAAO,EAAE,QAAQ;YAE1D,oBAAoB;YACpB,aAAa,MAAM;YAEnB,6BAA6B;YAC7B,OAAO,IAAI;QACb,EAAE,OAAO,cAAc;YACrB,uDAAuD;YACvD,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,aAAa,UAAU,CAAC;YACxB,aAAa,UAAU,CAAC;YACxB,OAAO,QAAQ,CAAC,IAAI,GAAG;YACvB,aAAa;YACb,OAAO,QAAQ,MAAM,CAAC;QACxB,SAAU;YACR,eAAe;QACjB;IACF;IAEA,gCAAgC;IAChC,OAAO,QAAQ,MAAM,CAAC;AACxB;uCAGa"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/USER/OneDrive/Documents/Coblabsite/blaffa_site/src/lib/push-notifications.ts"],"sourcesContent":["import { initializeApp, getApp, getApps } from 'firebase/app';\r\nimport { getMessaging, getToken, onMessage, Messaging } from 'firebase/messaging';\r\nimport api from './axios';\r\n\r\nconst firebaseConfig = {\r\n    apiKey: \"AIzaSyCpYf8cR98sJ9Vw12ARlXFUqJyy3PSI1Vg\",\r\n    authDomain: \"betpay-509eb.firebaseapp.com\",\r\n    projectId: \"betpay-509eb\",\r\n    storageBucket: \"betpay-509eb.firebasestorage.app\",\r\n    messagingSenderId: \"827338495555\",\r\n    appId: \"1:827338495555:web:9949d7c2caffe2b599e6f6\",\r\n    vapidKey: \"BFHKpREc3F52Eb4uBMUMmfuQQBj7yd_5IjXK248ZeVKO7axslH2S3s09DEo5r1zwQ3Apz4xZnNiyNBmx3vVNv38\"\r\n};\r\n\r\nlet isInitialized = false;\r\n\r\n/**\r\n * Registry device on backend\r\n */\r\nasync function registerDeviceOnBackend(token: string, type: 'web' | 'android' | 'ios') {\r\n    try {\r\n        const accessToken = localStorage.getItem('accessToken');\r\n        if (!accessToken) {\r\n            console.log('‚ö†Ô∏è [TEST LOG] No access token found, skipping backend registration');\r\n            return;\r\n        }\r\n\r\n        console.log(`üì± [TEST LOG] Registering device on backend with token: ${token.substring(0, 10)}...`);\r\n        await api.post(\r\n            `/blaffa/devices/`,\r\n            { registration_id: token, type },\r\n            { headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n        console.log('‚úÖ [TEST LOG] Device registered successfully on backend');\r\n    } catch (error) {\r\n        console.error('‚ùå [TEST LOG] Error registering device on backend:', error);\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize Push Notifications for Web using Firebase\r\n */\r\nexport async function initializePushNotifications(): Promise<void> {\r\n    console.log('üöÄ [TEST LOG] initializePushNotifications() called at:', new Date().toISOString());\r\n\r\n    // Ne pas initialiser plusieurs fois\r\n    if (isInitialized) {\r\n        console.log('‚ö†Ô∏è [TEST LOG] Push notifications already initialized, skipping...');\r\n        return;\r\n    }\r\n\r\n    console.log('üîç [TEST LOG] Checking platform compatibility...');\r\n\r\n    // Sur le web, on v√©rifie si le navigateur supporte les Service Workers et le Push\r\n    if (typeof window === 'undefined' || !('serviceWorker' in navigator) || !('PushManager' in window)) {\r\n        console.log('‚ùå [TEST LOG] Push notifications not available on this browser - exiting');\r\n        return;\r\n    }\r\n\r\n    console.log(`‚úÖ [TEST LOG] Initializing push notifications on web platform (loading from remote URL)`);\r\n    console.log(`‚ÑπÔ∏è [TEST LOG] Navigator serviceWorker available: true`);\r\n\r\n    try {\r\n        // V√©rifier d'abord l'√©tat actuel des permissions\r\n        console.log('üîê [TEST LOG] Checking current push notification permissions...');\r\n        let permStatus = Notification.permission;\r\n        console.log('üîê [TEST LOG] Current permission status:', permStatus);\r\n\r\n        // Si la permission n'a pas encore √©t√© demand√©e (default), la demander\r\n        if (permStatus === 'default') {\r\n            console.log('üìã [TEST LOG] Requesting push notification permissions...');\r\n            permStatus = await Notification.requestPermission();\r\n            console.log('üìã [TEST LOG] Permission request result:', permStatus);\r\n        } else if (permStatus === 'denied') {\r\n            console.warn('üö´ [TEST LOG] Push notification permission denied by user. User can enable it in browser settings.');\r\n            return;\r\n        } else if (permStatus === 'granted') {\r\n            console.log('‚úÖ [TEST LOG] Push notification permission already granted');\r\n        }\r\n\r\n        // V√©rifier si la permission a √©t√© accord√©e avant de continuer\r\n        if (permStatus !== 'granted') {\r\n            console.warn('üö´ [TEST LOG] Push notification permission not granted:', permStatus);\r\n            return;\r\n        }\r\n\r\n        console.log('‚úÖ [TEST LOG] Push notification permission granted, setting up Firebase Messaging...');\r\n\r\n        // Initialiser Firebase (si pas d√©j√† fait)\r\n        const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();\r\n        const messaging = getMessaging(app);\r\n\r\n        // Sur Android avec Capacitor, on cr√©e un canal. Sur le web, on simule l'initialisation du canal \"blaffa\"\r\n        console.log('‚úÖ [TEST LOG] High priority notification channel \"blaffa\" configured for web');\r\n\r\n        console.log('üëÇ [TEST LOG] Adding push notification event listeners...');\r\n\r\n        // √âcouter les messages re√ßus au premier plan\r\n        onMessage(messaging, (payload) => {\r\n            console.log('üì® [TEST LOG] Push notification received while app in foreground:', {\r\n                title: payload.notification?.title,\r\n                body: payload.notification?.body,\r\n                data: payload.data,\r\n                timestamp: new Date().toISOString(),\r\n            });\r\n\r\n            // Afficher une notification locale via le Service Worker registration\r\n            navigator.serviceWorker.ready.then((registration) => {\r\n                registration.showNotification(payload.notification?.title || 'Notification', {\r\n                    body: payload.notification?.body || '',\r\n                    icon: '/logo.png', // Chemin vers votre ic√¥ne\r\n                    data: payload.data,\r\n                });\r\n                console.log('‚úÖ [TEST LOG] Local notification shown for foreground push notification');\r\n            });\r\n        });\r\n\r\n        console.log('üìù [TEST LOG] Requesting FCM registration token...');\r\n        const fcmToken = await getToken(messaging, {\r\n            vapidKey: firebaseConfig.vapidKey,\r\n        });\r\n\r\n        if (fcmToken) {\r\n            console.log('üîî [TEST LOG] Push registration success! Token received:', {\r\n                token_preview: fcmToken.substring(0, 30) + '...',\r\n                full_token_length: fcmToken.length,\r\n                timestamp: new Date().toISOString(),\r\n            });\r\n\r\n            console.log(`üì± [TEST LOG] Platform detected: web, preparing to send token to backend...`);\r\n            await registerDeviceOnBackend(fcmToken, 'web');\r\n        } else {\r\n            console.warn('‚ö†Ô∏è [TEST LOG] No registration token received from FCM');\r\n        }\r\n\r\n        isInitialized = true;\r\n        console.log('‚úÖ [TEST LOG] Push notifications registration initiated successfully!');\r\n\r\n    } catch (error) {\r\n        console.error('Error initializing push notifications:', error);\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,MAAM,iBAAiB;IACnB,QAAQ;IACR,YAAY;IACZ,WAAW;IACX,eAAe;IACf,mBAAmB;IACnB,OAAO;IACP,UAAU;AACd;AAEA,IAAI,gBAAgB;AAEpB;;CAEC,GACD,eAAe,wBAAwB,KAAa,EAAE,IAA+B;IACjF,IAAI;QACA,MAAM,cAAc,aAAa,OAAO,CAAC;QACzC,IAAI,CAAC,aAAa;YACd,QAAQ,GAAG,CAAC;YACZ;QACJ;QAEA,QAAQ,GAAG,CAAC,CAAC,wDAAwD,EAAE,MAAM,SAAS,CAAC,GAAG,IAAI,GAAG,CAAC;QAClG,MAAM,8HAAG,CAAC,IAAI,CACV,CAAC,gBAAgB,CAAC,EAClB;YAAE,iBAAiB;YAAO;QAAK,GAC/B;YAAE,SAAS;gBAAE,gBAAgB;YAAmB;QAAE;QAEtD,QAAQ,GAAG,CAAC;IAChB,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,qDAAqD;IACvE;AACJ;AAKO,eAAe;IAClB,QAAQ,GAAG,CAAC,0DAA0D,IAAI,OAAO,WAAW;IAE5F,oCAAoC;IACpC,IAAI,eAAe;QACf,QAAQ,GAAG,CAAC;QACZ;IACJ;IAEA,QAAQ,GAAG,CAAC;IAEZ,kFAAkF;IAClF,IAAI,kDAAkB,eAAe,CAAC,CAAC,mBAAmB,SAAS,KAAK,CAAC,CAAC,iBAAiB,MAAM,GAAG;QAChG,QAAQ,GAAG,CAAC;QACZ;IACJ;;;AAoFJ"}}]
}